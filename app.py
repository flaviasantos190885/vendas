# -*- coding: utf-8 -*-
"""Vendas _Flavia_Jefin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1koVhCqD_jTxL75NRRzmmgoe31zgXe-qa

#Instalações
"""

#!pip install dash dash-bootstrap-components plotly pandas openpyxl

"""#Importações"""

import pandas as pd
import dash
from dash import Dash, dcc, html, Input, Output
import plotly.express as px
import dash_bootstrap_components as dbc

"""#Carregar planilhas de vendas"""

#Vendas
vendas_2020 = pd.read_excel("Base Vendas - 2020.xlsx")
vendas_2021 = pd.read_excel("Base Vendas - 2021.xlsx")
vendas_2022 = pd.read_excel("Base Vendas - 2022.xlsx")
df_vendas = pd.concat([vendas_2020, vendas_2021, vendas_2022], ignore_index=True)

# Clientes
df_clientes = pd.read_excel("Cadastro Clientes.xlsx")

# Produtos
df_produtos = pd.read_excel("Cadastro Produtos.xlsx")

# Lojas
df_lojas = pd.read_excel("Cadastro Lojas.xlsx")

"""#Cópias DFs"""

#Fazer cópia dos dfs
vendas = df_vendas.copy()
clientes = df_clientes.copy()
produtos = df_produtos.copy()
lojas = df_lojas.copy()

"""#Tratar dados"""

# Exibir os nomes das colunas
print(clientes.columns.tolist())

# Exibir os nomes das colunas
print(produtos.columns.tolist())

# Exibir os nomes das colunas
print(lojas.columns.tolist())

#Precisei carregar de novo o arquivo para ignorar das duas primeira linhas em branco e fazer a cópia
#o codigo abaixo ignora estas duas primeiras linhas para retornar os nomes certos das colunas
df_clientes = pd.read_excel("Cadastro Clientes.xlsx", skiprows=2)
clientes = df_clientes.copy()

#Visualizando linhas

print(clientes.head(5))

print(produtos.head(5))

print(lojas.head(5))

# Exibir os nomes das colunas
print(clientes.columns.tolist())

# Exibir os nomes das colunas
print(produtos.columns.tolist())

# Exibir os nomes das colunas
print(lojas.columns.tolist())

# Criar a coluna combinada
clientes['Cliente'] = clientes['Primeiro Nome'] + ' ' + clientes['Sobrenome']

# Remover as colunas antigas
clientes.drop(['Primeiro Nome', 'Sobrenome'], axis=1, inplace=True)

# Verificar as colunas restantes
print(clientes.columns.tolist())

# Reordenar as colunas com "Cliente" logo após "ID Cliente"
cols = clientes.columns.tolist()

# Remove a coluna "Cliente" da posição atual
cols.remove("Cliente")

# Insere a coluna "Cliente" após "ID Cliente"
idx = cols.index("ID Cliente") + 1
cols.insert(idx, "Cliente")

# Reordenar o DataFrame
clientes = clientes[cols]

# Verificar as colunas restantes
print(clientes.columns.tolist())

#Verificar os dados nas colunas Unnamed 10 e Unnamed 11
print(clientes[['Unnamed: 10', 'Unnamed: 11']].dropna())

#Colunas estão em branco, fazer a remoção
clientes.drop(columns=['Unnamed: 10', 'Unnamed: 11'], inplace=True)

# Verificar as colunas restantes
print(clientes.columns.tolist())

# Renomeando a coluna 'SKU' para 'ID Produto'
produtos = produtos.rename(columns={'SKU': 'ID Produto'})
vendas = vendas.rename(columns={'SKU': 'ID Produto'})

# Verificar as colunas restantes
print(vendas.columns.tolist())
print(clientes.columns.tolist())
print(produtos.columns.tolist())
print(lojas.columns.tolist())

# Unificar os dados
df = vendas.merge(clientes, on="ID Cliente", how="left") \
           .merge(produtos, on="ID Produto", how="left") \
           .merge(lojas, on="ID Loja", how="left")

# Converter a data de venda para datetime
df['Data da Venda'] = pd.to_datetime(df['Data da Venda'])

# Criar a coluna de Ano
df['Ano'] = df['Data da Venda'].dt.year

# Criar a coluna de Valor da Venda
df['Valor Venda'] = df['Qtd Vendida'] * df['Preço Unitario']

"""#Dashboard"""

# colunas do df
print(df.columns.tolist())

app = Dash(__name__, external_stylesheets=[dbc.themes.CYBORG])

app.layout = dbc.Container([
    html.H1("Dashboard de Vendas", className="text-center text-white my-4"),

    dbc.Row([
        dbc.Col([
            html.H5("Filtros", className="text-white mb-3"),

            dcc.Dropdown(df["Produto"].unique(), id="filtro_produto",
                         placeholder="Filtrar por Produto", className="mb-2"),

            dcc.Dropdown(df["Nome da Loja"].unique(), id="filtro_loja",
                         placeholder="Filtrar por Loja", className="mb-2"),

            dcc.Dropdown(df["Cliente"].unique(), id="filtro_cliente",
                         placeholder="Filtrar por Cliente", className="mb-2"),

            dcc.Dropdown(df["Marca"].unique(), id="filtro_marca",
                         placeholder="Filtrar por Marca", className="mb-2"),

            dcc.Dropdown(df["Tipo do Produto"].unique(), id="filtro_tipo_produto",
                         placeholder="Filtrar por Tipo Produto", className="mb-2"),

            dcc.Dropdown(id="filtro_marca_dinamica", placeholder="Selecione uma Marca", className="mb-2"),

        ], md=3),

        dbc.Col([
            dbc.Row([
                dbc.Col(dcc.Graph(id="grafico_vendas_ano"), md=6),
                dbc.Col(dcc.Graph(id="grafico_vendas_cliente"), md=6),
            ]),

            dbc.Row([
                dbc.Col(dcc.Graph(id="grafico_vendas_produto"), md=6),
                dbc.Col(dcc.Graph(id="grafico_vendas_loja"), md=6),
            ]),

            dbc.Row([
                dbc.Col(dcc.Graph(id="grafico_pizza_tipo"), md=6),
                dbc.Col(dcc.Graph(id="grafico_area_marca"), md=6),
            ]),
        ], md=9)
    ])
], fluid=True)

@app.callback(
    Output("filtro_marca_dinamica", "options"),
    Input("filtro_tipo_produto", "value")
)
def atualizar_dropdown_marca(tipo_produto):
    if tipo_produto:
        marcas = df[df["Tipo do Produto"] == tipo_produto]["Marca"].unique()
        return [{"label": m, "value": m} for m in marcas]
    return []

@app.callback(
    Output("grafico_vendas_ano", "figure"),
    Output("grafico_vendas_cliente", "figure"),
    Output("grafico_vendas_produto", "figure"),
    Output("grafico_vendas_loja", "figure"),
    Output("grafico_pizza_tipo", "figure"),
    Output("grafico_area_marca", "figure"),

    Input("filtro_produto", "value"),
    Input("filtro_loja", "value"),
    Input("filtro_cliente", "value"),
    Input("filtro_marca", "value"),
    Input("filtro_tipo_produto", "value"),
    Input("filtro_marca_dinamica", "value")
)
def atualizar_graficos(produto, loja, cliente, marca, tipo, marca_dinamica):
    dff = df.copy()

    for coluna, valor in zip(
        ["Produto", "Nome da Loja", "Cliente", "Marca", "Tipo do Produto"],
        [produto, loja, cliente, marca, tipo]
    ):
        if valor:
            dff = dff[dff[coluna] == valor]

    if marca_dinamica:
        dff = dff[dff["Marca"] == marca_dinamica]

    # Gráfico 1 - Vendas por Ano
    fig1 = px.bar(dff, x="Ano", y="Valor Venda",
                  title="Vendas por Ano", template="plotly_dark",
                  color="Ano", color_discrete_sequence=px.colors.qualitative.Set1)

    # Gráfico 2 - Vendas por Cliente
    fig2 = px.bar(dff, x="Cliente", y="Valor Venda",
                  title="Vendas por Cliente", template="plotly_dark",
                  color="Cliente", color_discrete_sequence=px.colors.qualitative.Pastel1)

    # Gráfico 3 - Vendas por Produto
    fig3 = px.bar(dff, x="Produto", y="Valor Venda",
                  title="Vendas por Produto", template="plotly_dark",
                  color="Produto", color_discrete_sequence=px.colors.qualitative.Bold)

    # Gráfico 4 - Vendas por Loja
    fig4 = px.bar(dff, x="Valor Venda", y="Nome da Loja", orientation="h",
                  title="Vendas por Loja", template="plotly_dark",
                  color="Nome da Loja", color_discrete_sequence=px.colors.qualitative.Alphabet)

    # Gráfico 5 - Pizza por Tipo de Produto
    fig5 = px.pie(dff, names="Tipo do Produto", values="Valor Venda",
                  title="Distribuição por Tipo de Produto", template="plotly_dark",
                  color_discrete_sequence=px.colors.sequential.Magma)

    # Gráfico 6 - Vendas por Marca ao Longo dos Anos
    fig6 = px.area(dff, x="Ano", y="Valor Venda", color="Marca",
                   title="Vendas por Marca ao Longo dos Anos", template="plotly_dark",
                   color_discrete_sequence=px.colors.qualitative.Vivid)

    return fig1, fig2, fig3, fig4, fig5, fig6

server = app.server
